### 碎片知识

1. mysql日志类型

```
binlog（归档日志）；
MySQL Server 层记录的日志，所以不管是用的什么存储引擎，只要是 MySQL 都是会有 binlog 的存在，在做 MySQL 主从复制的时候，利用的就是 binlog。
redo log（重做日志）；
InnoDB 存储引擎层方面的日志，所以如果你使用的存储引擎不是 InnoDB 的话，那就根本谈不上 redo log。
undo log（撤消日志）；
```

2. 索引失效

```
不满足最左匹配原则：从左往右匹配；；
使用了select *：查询所有列的数据，大概率会查询非索引列的数据，非索引列不会走索引，查询效率非常低。；
索引列上有计算；
索引列使用了函数；
字段类型不同；
like左边包含了%；
列对比；
使用or关键字；
not in和not exists；
order by的坑；
```

3. 事务隔离级别

```
读未提交（READ UNCOMMITTED）
读未提交，也叫未提交读，该隔离级别的事务可以看到其他事务中未提交的数据。该隔离级别因为可以读取到其他事务中未提交的数据，而未提交的数据可能会发生回滚，因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为脏读。
读已提交（READ COMMITTED）
读已提交，也叫提交读，该隔离级别的事务能读取到已经提交事务的数据，因此它不会有脏读问题。但由于在事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同 SQL 查询中，可能会得到不同的结果，这种现象叫做不可重复读。
可重复读（REPEATABLE READ）
可重复读，是 MySQL 的默认事务隔离级别，它能确保同一事务多次查询的结果一致。但也会有新的问题，比如此级别的事务正在执行时，另一个事务成功的插入了某条数据，但因为它每次查询的结果都是一样的，所以会导致查询不到这条数据，自己重复插入时又失败（因为唯一约束的原因）。明明在事务中查询不到这条信息，但自己就是插入不进去，这就叫幻读 （Phantom Read）。
序列化（SERIALIZABLE）
序列化，事务最高隔离级别，它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读问题，但因为执行效率低，所以真正使用的场景并不多。
```

4. B-Tree和B+Tree的区别

```
B-Tree 中，所有节点都会带有指向具体记录的指针；B+Tree 中只有叶子结点会带有指向具体记录的指针。
B-Tree 中不同的叶子之间没有连在一起；B+Tree 中所有的叶子结点通过指针连接在一起。
B-Tree 中可能在非叶子结点就拿到了指向具体记录的指针，搜索效率不稳定；B+Tree 中，一定要到叶子结点中才可以获取到具体记录的指针，搜索效率稳定。
```

5. 聚簇索引和非聚簇索引

```
我们日常所说的主键索引，其实就是聚簇索引（Clustered Index）;主键索引之外，其他的都称之为非主键索引，非主键索引也被称为二级索引（Secondary Index），或者叫作辅助索引。
区别：
主键索引的叶子结点存储的是一行完整的数据。
非主键索引的叶子结点存储的则是主键值。
```

5. 回表

```
用非索引字段去搜索，拿到主键值后再去搜索主键索引，这个过程就是所谓的回表。
```

6. B+Tree的特点
```
1. 是多叉而不是二叉了，使用多叉的目的是降低树的高度;
2. 每个节点不再只是存储一个key了，可以存储多个key；
3. 非叶子节点存储key，叶子节点存储key和数据。
4. 叶子节点两两相连，为顺序查询提供了帮助
```

7. Mysql为什么选择B+树
```
1. B+树的非叶子节点只是存储key，占用空间非常小，因此每一层的节点能索引到的数据范围更加的广。换句话说，每次IO操作可以观看更多的数据；
2. 叶子节点两两相连，符合磁盘的预读特性。如图三中存储50和55的叶子节点，它有个指针指向了60和62这个叶子节点，那么当我们从磁盘读取50和55对应的数据的时候，由于磁盘的预读特性，会顺便把60和62对应的数据读取出来。这个时候属于顺序读取，而不是磁盘寻道了，加快了速度。
3. 支持范围查询，而且部分范围查询非常高效，原因是数据都是存储在叶子节点这一层，并且有指针指向其他叶子节点，这样范围查询只需要遍历叶子节点这一层，无需整棵树遍历。
```
